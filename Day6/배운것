# 2022.08.26 금요일 못먹어도 고

### java를 종료한다는 것

```java
System.exit(0)을 사용하여 Java 메소드 종료

 public static void exampleMethod() {
        for (int i = 0; i < 10; i++) {
            if (i > 3) {
                System.exit(0);
            }
            System.out.println("i: " + i);
        }
    }
```

return을 사용하여 Java 메소드 종료  
메소드를 종료하는 또 다른 방법은return키워드를 사용하는 것입니다.  
이 키워드는 사용할 때 메서드 실행을 완료하며 함수에서 값을 반환하는 데 사용할 수도 있습니다.

아래 예에는num1및num2의 두 매개 변수를 사용하는exampleMethod메소드가 있습니다.  
메소드에서 빼기를 수행하지만num2가num1보다 큰지 확인하고이 조건이 true가되면return이 메소드를 종료하고 실행이 완료됩니다.  
void를 반환 유형으로 사용하므로이 메서드는 값을 반환하지 않습니다.

```java
public class ExitMethod {
    public static void main(String[] args) {

        exampleMethod(2, 5);
        exampleMethod(3, 2);
        exampleMethod(100, 20);
        exampleMethod(102, 110);
    }

    public static void exampleMethod(int num1, int num2) {

        if (num2 > num1)
            return;

        int subtractedValue = num1 - num2;
        System.out.println(subtractedValue);


    }
```

### Getter Setter

원칙적으로 실무에서 사용하는 것과 동일한 방식으로...

1. 캡슐화 : 정보를 저장하는 (memeber field)에 대해서
2. 캡슐화 : 간접적으로 처리할 수 있는 코드가 필요---> setter, getter함수
3. 이런 데이터를 담을 수 있는 클래스 (DTO, VO, DOMAIN) 보통은 DTO를 많이 쓴다.

필요에 따라서 getter만 만드는 경우가 있고-->write만 하겠따  
필요에 따라서 setter만 만드는 경우가 있고-->read만 하겠다  
둘다 만드는 경우가 있다.--> 둘다 하겠다.

**_쉽게 만드는 방법_**

1. IDE를 사용해서 source--> generate getter setter
2. spring 때 배울것이지만 lombook라이브러리를 이용  
   Lombok 이란 Java 라이브러리로 반복되는 getter, setter, toString .
   등의 반복 메서드 작성 코드를 줄여주는 코드 다이어트 라이브러리 이다.  
   @Getter  
   @Stter  
   컴파일러에게 자동으로 setter, getter함수를 만들어 달라는 요청이다.  
   필요하다면 별도의 함수를 생성
   speed를 10씩 올리거나 감소하는 기능을 만들어라
   일반적으로 아래처러므 별도의 함수를 만들기 보다는 read와 write를 한다면
   setter와 getter를 통해서 제어하는 것이 일반적이다.

```java
public class Car {
	private int window;//굳이 초기화가 필요없다 default값을 가지기 때문에
	private  int  speed;
    public void speedUp() {
		speed+=10;
	}
	public void speedDown() {

		if(speed>0) {
			speed-=10;
		}else {
			speed=0;
		}
	}
	public int getWindow() {
		return window;

	}
	public void setWindow(int data) { //this를 안배워서 이렇게 쓰는데 원해는 setWindow (int window){this...}
		window = data;//setter 함수


	}

	public int getSpeed() {
		return speed;
	}
	public void setSpeed(int speed) {
		this.speed = speed;
	}
}
```

### static

instance variable >> class Car{private Stirng color;}  
생성되는 객체마다 다른 색상을 가질 수 있다.

local variable>> class Car{public void move(){ int speed=0;}}  
습관적으로 지역안에 있는 변수는 초기화를 하자

block variable >> class Car{public void move(){for(int t;i<10.....)}제어생성... 소멸
static variable >> 공유자원 (객체간), 객체 생성 이전에 memory 올라가는 자원 ( 영역 : class area, method area)

객체를 만드는 유일한 방법은 new를 통해서 memory에 올리는 것이라고 하셨지만  
static은 new없이도 memory에 올라간다.
Ex06_Variable_Scope 클래스 >> 구체화(메모리)>>Ex06_Variable_Scope>> 이 클래스는 new를 한 적이 없었다 한번도

1. class variable(클래스 변수) ,일반적으로 static variable(객체간 공유자원)
2. 목적 : 정보를 담는것 (생성되는 모든 객체가 공유하는 자원)  
   생성되는 모든 객체라는 것은 (heap영역에 생성된 객체들이 공유하는 자원)
3. 접근방법  
   1.class 이름.static변수명>> Variable.cv>>why(객체가 생성되기 전에...접근
4. Variable v =new Variable();>>c.cv  
   Variable v2 =new Variable();>>v2.cv  
   v.cv의 주소값과 v2.cv(같은 주소를 바라본다 : static 변수 주소)
5. 생성시점  
   Hello.java>javac Hello.java>Hello.class  
   java.exe Hello 엔터 실행  
   JVM>OS>Memory빌려 > 정리(영역을 나누어요)>class Loader system 분석  
   클래스 정보(metadata : 설명) >> clss area(method area)메모리에 올림( 언제. 어떤 자원, 버전..)  
   그 클래스 안에 static variable 또는 static method있다면 두녀석을 class area(method area) 영역에 할당합니다.  
    그런데 그 함수의 이름이 만약에 main() 이라면 정해진 규칙에 따라서 실행합니다(Stack영역) 자원 할당...

```java

```

```java

```
